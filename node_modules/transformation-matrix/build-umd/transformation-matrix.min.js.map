{"version":3,"file":"transformation-matrix.min.js","mappings":"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","sources":["webpack://TransformationMatrix/webpack/universalModuleDefinition","webpack://TransformationMatrix/webpack/bootstrap","webpack://TransformationMatrix/webpack/runtime/define property getters","webpack://TransformationMatrix/webpack/runtime/hasOwnProperty shorthand","webpack://TransformationMatrix/webpack/runtime/make namespace object","webpack://TransformationMatrix/./src/applyToPoint.js","webpack://TransformationMatrix/./src/fromObject.js","webpack://TransformationMatrix/./src/fromString.js","webpack://TransformationMatrix/./src/identity.js","webpack://TransformationMatrix/./src/inverse.js","webpack://TransformationMatrix/./src/utils.js","webpack://TransformationMatrix/./src/isAffineMatrix.js","webpack://TransformationMatrix/./src/translate.js","webpack://TransformationMatrix/./src/transform.js","webpack://TransformationMatrix/./src/rotate.js","webpack://TransformationMatrix/./src/scale.js","webpack://TransformationMatrix/./src/shear.js","webpack://TransformationMatrix/./src/skew.js","webpack://TransformationMatrix/./src/toString.js","webpack://TransformationMatrix/./src/smoothMatrix.js","webpack://TransformationMatrix/./src/fromTriangles.js","webpack://TransformationMatrix/./src/fromDefinition.js","webpack://TransformationMatrix/./src/fromTransformAttribute.autogenerated.js","webpack://TransformationMatrix/./src/fromTransformAttribute.js","webpack://TransformationMatrix/./src/decompose.js","webpack://TransformationMatrix/./src/flip.js","webpack://TransformationMatrix/./src/fromMovingPoints.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TransformationMatrix\"] = factory();\n\telse\n\t\troot[\"TransformationMatrix\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Calculate a point transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param  point {Point} Point\n * @returns {Point} Point\n */\nexport function applyToPoint (matrix, point) {\n  return Array.isArray(point)\n    ? [\n        matrix.a * point[0] + matrix.c * point[1] + matrix.e,\n        matrix.b * point[0] + matrix.d * point[1] + matrix.f\n      ]\n    : {\n        x: matrix.a * point.x + matrix.c * point.y + matrix.e,\n        y: matrix.b * point.x + matrix.d * point.y + matrix.f\n      }\n}\n\n/**\n * Calculate an array of points transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param points {Point[]} Array of point\n * @returns {Point[]} Array of point\n */\nexport function applyToPoints (matrix, points) {\n  return points.map(point => applyToPoint(matrix, point))\n}\n","/**\n * Extract an affine matrix from an object that contains a,b,c,d,e,f keys\n * Any value could be a float or a string that contains a float\n * @param object {Object} Object that contains a,b,c,d,e,f keys\n * @return {Matrix} Affine Matrix\n */\nexport function fromObject (object) {\n  return {\n    a: parseFloat(object.a),\n    b: parseFloat(object.b),\n    c: parseFloat(object.c),\n    d: parseFloat(object.d),\n    e: parseFloat(object.e),\n    f: parseFloat(object.f)\n  }\n}\n","/**\n * @ignore\n * @type {RegExp}\n */\nconst matrixRegex = /^matrix\\(\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*\\)$/i\n\n/**\n * Parse a string formatted as matrix(a,b,c,d,e,f)\n * @param string {string} String with an affine matrix\n * @returns {Matrix} Affine Matrix\n *\n * @example\n * > fromString('matrix(1,2,3,4,5,6)')\n * {a: 1, b: 2, c: 3, d: 4, c: 5, e: 6}\n */\nexport function fromString (string) {\n  const parseFloatOrThrow = number => {\n    const n = parseFloat(number)\n    if (Number.isFinite(n)) return n // excludes NaN, +Infinite, -Infinite\n    throw new Error(`'${string}' is not a matrix`)\n  }\n\n  const prefix = string.substring(0, 7).toLowerCase()\n  const suffix = string.substring(string.length - 1)\n  const body = string.substring(7, string.length - 1)\n  const elements = body.split(',')\n\n  if (\n    prefix === 'matrix(' &&\n    suffix === ')' &&\n    elements.length === 6\n  ) {\n    return {\n      a: parseFloatOrThrow(elements[0]),\n      b: parseFloatOrThrow(elements[1]),\n      c: parseFloatOrThrow(elements[2]),\n      d: parseFloatOrThrow(elements[3]),\n      e: parseFloatOrThrow(elements[4]),\n      f: parseFloatOrThrow(elements[5])\n    }\n  }\n\n  throw new Error(`'${string}' is not a matrix`)\n}\n\n/**\n * Parse a string formatted as matrix(a,b,c,d,e,f) - Legacy implementation of `fromString(matrix)`;\n * Read this PR for details {@link https://github.com/chrvadala/transformation-matrix/pull/107}\n * @param string {string} String with an affine matrix\n * @deprecated\n * @returns {Matrix} Affine Matrix\n *\n * @example\n * > fromStringLegacy('matrix(1,2,3,4,5,6)')\n * {a: 1, b: 2, c: 3, d: 4, c: 5, e: 6}\n */\nexport function fromStringLegacy (string) {\n  const parsed = string.match(matrixRegex)\n  if (parsed === null || parsed.length < 7) throw new Error(`'${string}' is not a matrix`)\n  return {\n    a: parseFloat(parsed[1]),\n    b: parseFloat(parsed[2]),\n    c: parseFloat(parsed[3]),\n    d: parseFloat(parsed[4]),\n    e: parseFloat(parsed[5]),\n    f: parseFloat(parsed[6])\n  }\n}\n","/**\n * Identity matrix\n * @returns {Matrix} Affine Matrix\n */\nexport function identity () {\n  return {\n    a: 1,\n    c: 0,\n    e: 0,\n    b: 0,\n    d: 1,\n    f: 0\n  }\n}\n","/**\n * Calculate a matrix that is the inverse of the provided matrix\n * @param matrix {Matrix} Affine Matrix\n * @returns {Matrix} Inverted Affine Matrix\n */\nexport function inverse (matrix) {\n  // http://www.wolframalpha.com/input/?i=Inverse+%5B%7B%7Ba,c,e%7D,%7Bb,d,f%7D,%7B0,0,1%7D%7D%5D\n\n  const { a, b, c, d, e, f } = matrix\n\n  const denom = a * d - b * c\n\n  return {\n    a: d / denom,\n    b: b / -denom,\n    c: c / -denom,\n    d: a / denom,\n    e: (d * e - c * f) / -denom,\n    f: (b * e - a * f) / denom\n  }\n}\n","export function isUndefined (val) {\n  return typeof val === 'undefined'\n}\n\nexport function isNumeric (n) {\n  return typeof n === 'number' &&\n    !Number.isNaN(n) &&\n    Number.isFinite(n)\n}\n\nexport function isObject (obj) {\n  return typeof obj === 'object' &&\n    obj !== null &&\n    !Array.isArray(obj)\n}\n\nexport function matchesShape (obj, keys) {\n  return keys.every(key => key in obj)\n}\n","import { isNumeric, isObject } from './utils'\n\n/**\n * Check if the object contain an affine matrix\n * @param object {Object} Generic Plain Object\n * @return {boolean} True if is an object and contains an affine matrix\n */\n\nexport function isAffineMatrix (object) {\n  return isObject(object) &&\n    'a' in object &&\n    isNumeric(object.a) &&\n    'b' in object &&\n    isNumeric(object.b) &&\n    'c' in object &&\n    isNumeric(object.c) &&\n    'd' in object &&\n    isNumeric(object.d) &&\n    'e' in object &&\n    isNumeric(object.e) &&\n    'f' in object &&\n    isNumeric(object.f)\n}\n","/**\n * Calculate a translate matrix\n * @param tx {number} Translation on axis x\n * @param [ty = 0] {number} Translation on axis y\n * @returns {Matrix} Affine Matrix\n */\nexport function translate (tx, ty = 0) {\n  return {\n    a: 1,\n    c: 0,\n    e: tx,\n    b: 0,\n    d: 1,\n    f: ty\n  }\n}\n","/**\n * Merge multiple matrices into one\n * @param matrices {...Matrix | Matrix[]} Matrices listed as separate parameters or in an array\n * @returns {Matrix} Affine Matrix\n */\nexport function transform (...matrices) {\n  matrices = Array.isArray(matrices[0]) ? matrices[0] : matrices\n\n  const multiply = (m1, m2) => {\n    return {\n      a: m1.a * m2.a + m1.c * m2.b,\n      c: m1.a * m2.c + m1.c * m2.d,\n      e: m1.a * m2.e + m1.c * m2.f + m1.e,\n      b: m1.b * m2.a + m1.d * m2.b,\n      d: m1.b * m2.c + m1.d * m2.d,\n      f: m1.b * m2.e + m1.d * m2.f + m1.f\n    }\n  }\n\n  switch (matrices.length) {\n    case 0:\n      throw new Error('no matrices provided')\n\n    case 1:\n      return matrices[0]\n\n    case 2:\n      return multiply(matrices[0], matrices[1])\n\n    default: {\n      const [m1, m2, ...rest] = matrices\n      const m = multiply(m1, m2)\n      return transform(m, ...rest)\n    }\n  }\n}\n\n/**\n * Merge multiple matrices into one\n * @param matrices {...Matrix | Matrix[]} Matrices listed as separate parameters or in an array\n * @returns {Matrix} Affine Matrix\n */\nexport function compose (...matrices) {\n  return transform(...matrices)\n}\n","import { isUndefined } from './utils'\nimport { translate } from './translate'\nimport { transform } from './transform'\n\nconst { cos, sin, PI } = Math\n/**\n * Calculate a rotation matrix\n * @param angle {number} Angle in radians\n * @param [cx] {number} If (cx,cy) are supplied the rotate is about this point\n * @param [cy] {number} If (cx,cy) are supplied the rotate is about this point\n * @returns {Matrix} Affine Matrix\n */\nexport function rotate (angle, cx, cy) {\n  const cosAngle = cos(angle)\n  const sinAngle = sin(angle)\n  const rotationMatrix = {\n    a: cosAngle,\n    c: -sinAngle,\n    e: 0,\n    b: sinAngle,\n    d: cosAngle,\n    f: 0\n  }\n  if (isUndefined(cx) || isUndefined(cy)) {\n    return rotationMatrix\n  }\n\n  return transform([\n    translate(cx, cy),\n    rotationMatrix,\n    translate(-cx, -cy)\n  ])\n}\n\n/**\n * Calculate a rotation matrix with a DEG angle\n * @param angle {number} Angle in degree\n * @param [cx] {number} If (cx,cy) are supplied the rotate is about this point\n * @param [cy] {number} If (cx,cy) are supplied the rotate is about this point\n * @returns {Matrix} Affine Matrix\n */\nexport function rotateDEG (angle, cx = undefined, cy = undefined) {\n  return rotate(angle * PI / 180, cx, cy)\n}\n","import { isUndefined } from './utils'\nimport { translate } from './translate'\nimport { transform } from './transform'\n\n/**\n * Calculate a scaling matrix\n * @param sx {number} Scaling on axis x\n * @param [sy = sx] {number} Scaling on axis y (default sx)\n * @param [cx] {number} If (cx,cy) are supplied the scaling is about this point\n * @param [cy] {number} If (cx,cy) are supplied the scaling is about this point\n * @returns {Matrix} Affine Matrix\n */\nexport function scale (sx, sy = undefined, cx = undefined, cy = undefined) {\n  if (isUndefined(sy)) sy = sx\n\n  const scaleMatrix = {\n    a: sx,\n    c: 0,\n    e: 0,\n    b: 0,\n    d: sy,\n    f: 0\n  }\n\n  if (isUndefined(cx) || isUndefined(cy)) {\n    return scaleMatrix\n  }\n\n  return transform([\n    translate(cx, cy),\n    scaleMatrix,\n    translate(-cx, -cy)\n  ])\n}\n","/**\n * Calculate a shear matrix\n * @param shx {number} Shear on axis x\n * @param shy {number} Shear on axis y\n * @returns {Matrix} Affine Matrix\n */\nexport function shear (shx, shy) {\n  return {\n    a: 1,\n    c: shx,\n    e: 0,\n    b: shy,\n    d: 1,\n    f: 0\n  }\n}\n","// https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew\nconst { tan } = Math\n\n/**\n * Calculate a skew matrix\n * @param ax {number} Skew on axis x\n * @param ay {number} Skew on axis y\n * @returns {Matrix} Affine Matrix\n */\nexport function skew (ax, ay) {\n  return {\n    a: 1,\n    c: tan(ax),\n    e: 0,\n    b: tan(ay),\n    d: 1,\n    f: 0\n  }\n}\n\n/**\n * Calculate a skew matrix using DEG angles\n * @param ax {number} Skew on axis x\n * @param ay {number} Skew on axis y\n * @returns {Matrix} Affine Matrix\n */\nexport function skewDEG (ax, ay) {\n  return skew(ax * Math.PI / 180, ay * Math.PI / 180)\n}\n","/**\n * Serialize an affine matrix to a string that can be used with CSS or SVG\n * @param matrix {Matrix} Affine Matrix\n * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)\n */\nexport function toCSS (matrix) {\n  return toString(matrix)\n}\n\n/**\n * Serialize an affine matrix to a string that can be used with CSS or SVG\n * @param matrix {Matrix} Affine Matrix\n * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)\n */\nexport function toSVG (matrix) {\n  return toString(matrix)\n}\n\n/**\n * Serialize an affine matrix to a string that can be used with CSS or SVG\n * @param matrix {Matrix} Affine Matrix\n * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)\n */\nexport function toString (matrix) {\n  return `matrix(${matrix.a},${matrix.b},${matrix.c},${matrix.d},${matrix.e},${matrix.f})`\n}\n","/**\n * Rounds all elements of the given matrix using the given precision\n * @param matrix {Matrix} An affine matrix to round\n * @param [precision] {number} A precision to use for Math.round. Defaults to 10000000000 (meaning which rounds to the 10th digit after the comma).\n * @returns {Matrix} The rounded Affine Matrix\n */\nexport function smoothMatrix (matrix, precision = 10000000000) {\n  return {\n    a: Math.round(matrix.a * precision) / precision,\n    b: Math.round(matrix.b * precision) / precision,\n    c: Math.round(matrix.c * precision) / precision,\n    d: Math.round(matrix.d * precision) / precision,\n    e: Math.round(matrix.e * precision) / precision,\n    f: Math.round(matrix.f * precision) / precision\n  }\n}\n","import { inverse } from './inverse'\nimport { transform } from './transform'\nimport { smoothMatrix } from './smoothMatrix'\n\n/**\n * Returns a matrix that transforms a triangle t1 into another triangle t2, or throws an exception if it is impossible.\n * @param t1 {Point[]} Array of points containing the three points for the first triangle\n * @param t2 {Point[]} Array of points containing the three points for the second triangle\n * @returns {Matrix} Matrix which transforms t1 to t2\n * @throws Exception if the matrix becomes not invertible\n */\nexport function fromTriangles (t1, t2) {\n  // point p = first point of the triangle\n  const px1 = t1[0].x != null ? t1[0].x : t1[0][0]\n  const py1 = t1[0].y != null ? t1[0].y : t1[0][1]\n  const px2 = t2[0].x != null ? t2[0].x : t2[0][0]\n  const py2 = t2[0].y != null ? t2[0].y : t2[0][1]\n\n  // point q = second point of the triangle\n  const qx1 = t1[1].x != null ? t1[1].x : t1[1][0]\n  const qy1 = t1[1].y != null ? t1[1].y : t1[1][1]\n  const qx2 = t2[1].x != null ? t2[1].x : t2[1][0]\n  const qy2 = t2[1].y != null ? t2[1].y : t2[1][1]\n\n  // point r = third point of the triangle\n  const rx1 = t1[2].x != null ? t1[2].x : t1[2][0]\n  const ry1 = t1[2].y != null ? t1[2].y : t1[2][1]\n  const rx2 = t2[2].x != null ? t2[2].x : t2[2][0]\n  const ry2 = t2[2].y != null ? t2[2].y : t2[2][1]\n\n  const r1 = {\n    a: px1 - rx1,\n    b: py1 - ry1,\n    c: qx1 - rx1,\n    d: qy1 - ry1,\n    e: rx1,\n    f: ry1\n  }\n  const r2 = {\n    a: px2 - rx2,\n    b: py2 - ry2,\n    c: qx2 - rx2,\n    d: qy2 - ry2,\n    e: rx2,\n    f: ry2\n  }\n\n  const inverseR1 = inverse(r1)\n  const affineMatrix = transform([r2, inverseR1])\n\n  // round the matrix elements to smooth the finite inversion\n  return smoothMatrix(affineMatrix)\n}\n","import { fromObject } from './fromObject'\nimport { translate } from './translate'\nimport { scale } from './scale'\nimport { rotateDEG } from './rotate'\nimport { skewDEG } from './skew'\nimport { shear } from './shear'\n\n/**\n * Converts array of matrix descriptor to array of matrix\n * @param definitionOrArrayOfDefinition {Object[]} Array of object describing the matrix\n * @returns {Matrix[]} Array of matrix\n *\n * @example\n * > fromDefinition([\n *  { type: 'matrix', a:1, b:2, c:3, d:4, e:5, f:6 },\n *  { type: 'translate', tx: 10, ty: 20 },\n *  { type: 'scale', sx: 2, sy: 4 },\n *  { type: 'rotate', angle: 90, cx: 50, cy: 25 },\n *  { type: 'skewX', angle: 45 },\n *  { type: 'skewY',  angle: 45 },\n *  { type: 'shear', shx: 10, shy: 20}\n * ])\n *\n * [\n *  { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 },\n *  { a: 1, c: 0, e: 10, b: 0, d: 1, f: 20 },\n *  { a: 2, c: 0, e: 0, b: 0, d: 4, f: 0 },\n *  { a: 6.123, c: -1, e: 0, b: 1, d: 6.123, f: 0 },\n *  { a: 1, c: 0.99.., e: 0, b: 0, d: 1, f: 0 },\n *  { a: 1, c: 0, e: 0, b: 0.99, d: 1, f: 0 },\n *  { a: 1, c: 10, e: 0, b: 20, d: 1, f: 0 }\n * ]\n **/\nexport function fromDefinition (definitionOrArrayOfDefinition) {\n  return Array.isArray(definitionOrArrayOfDefinition)\n    ? definitionOrArrayOfDefinition.map(mapper)\n    : mapper(definitionOrArrayOfDefinition)\n\n  function mapper (descriptor) {\n    switch (descriptor.type) {\n      case 'matrix':\n        if ('a' in descriptor &&\n          'b' in descriptor &&\n          'c' in descriptor &&\n          'd' in descriptor &&\n          'e' in descriptor &&\n          'f' in descriptor\n        ) {\n          return fromObject(descriptor)\n        } else {\n          throw new Error('MISSING_MANDATORY_PARAM')\n        }\n\n      case 'translate':\n        if (!('tx' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n\n        if ('ty' in descriptor) return translate(descriptor.tx, descriptor.ty)\n\n        return translate(descriptor.tx)\n\n      case 'scale':\n        if (!('sx' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n\n        if ('sy' in descriptor) return scale(descriptor.sx, descriptor.sy)\n\n        return scale(descriptor.sx)\n\n      case 'rotate':\n        if (!('angle' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n\n        if ('cx' in descriptor && 'cy' in descriptor) {\n          return rotateDEG(descriptor.angle, descriptor.cx, descriptor.cy)\n        }\n        return rotateDEG(descriptor.angle)\n\n      case 'skewX':\n        if (!('angle' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n        return skewDEG(descriptor.angle, 0)\n\n      case 'skewY':\n        if (!('angle' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n        return skewDEG(0, descriptor.angle)\n\n      case 'shear':\n        if (!('shx' in descriptor && 'shy' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n        return shear(descriptor.shx, descriptor.shy)\n\n      default:\n        throw new Error('UNSUPPORTED_DESCRIPTOR')\n    }\n  }\n}\n","// @generated by Peggy 5.0.6.\n//\n// https://peggyjs.org/\n\n\nclass peg$SyntaxError extends SyntaxError {\n  constructor(message, expected, found, location) {\n    super(message);\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = \"SyntaxError\";\n  }\n\n  format(sources) {\n    let str = \"Error: \" + this.message;\n    if (this.location) {\n      let src = null;\n      const st = sources.find(s => s.source === this.location.source);\n      if (st) {\n        src = st.text.split(/\\r\\n|\\n|\\r/g);\n      }\n      const s = this.location.start;\n      const offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n        ? this.location.source.offset(s)\n        : s;\n      const loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n      if (src) {\n        const e = this.location.end;\n        const filler = \"\".padEnd(offset_s.line.toString().length, \" \");\n        const line = src[s.line - 1];\n        const last = s.line === e.line ? e.column : line.length + 1;\n        const hatLen = (last - s.column) || 1;\n        str += \"\\n --> \" + loc + \"\\n\"\n            + filler + \" |\\n\"\n            + offset_s.line + \" | \" + line + \"\\n\"\n            + filler + \" | \" + \"\".padEnd(s.column - 1, \" \")\n            + \"\".padEnd(hatLen, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  }\n\n  static buildMessage(expected, found) {\n    function hex(ch) {\n      return ch.codePointAt(0).toString(16).toUpperCase();\n    }\n\n    const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, \"unicode\")\n      ? new RegExp(\"[\\\\p{C}\\\\p{Mn}\\\\p{Mc}]\", \"gu\")\n      : null;\n    function unicodeEscape(s) {\n      if (nonPrintable) {\n        return s.replace(nonPrintable,  ch => \"\\\\u{\" + hex(ch) + \"}\");\n      }\n      return s;\n    }\n\n    function literalEscape(s) {\n      return unicodeEscape(s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\"/g,  \"\\\\\\\"\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\"  + hex(ch)));\n    }\n\n    function classEscape(s) {\n      return unicodeEscape(s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\\]/g, \"\\\\]\")\n        .replace(/\\^/g, \"\\\\^\")\n        .replace(/-/g,  \"\\\\-\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\"  + hex(ch)));\n    }\n\n    const DESCRIBE_EXPECTATION_FNS = {\n      literal(expectation) {\n        return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n      },\n\n      class(expectation) {\n        const escapedParts = expectation.parts.map(\n          part => (Array.isArray(part)\n            ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n            : classEscape(part))\n        );\n\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\" + (expectation.unicode ? \"u\" : \"\");\n      },\n\n      any() {\n        return \"any character\";\n      },\n\n      end() {\n        return \"end of input\";\n      },\n\n      other(expectation) {\n        return expectation.description;\n      },\n    };\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      const descriptions = expected.map(describeExpectation);\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        let j = 1;\n        for (let i = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  }\n}\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  const peg$FAILED = {};\n  const peg$source = options.grammarSource;\n\n  const peg$startRuleFunctions = {\n    transformList: peg$parsetransformList,\n  };\n  let peg$startRuleFunction = peg$parsetransformList;\n\n  const peg$c0 = \"matrix\";\n  const peg$c1 = \"(\";\n  const peg$c2 = \")\";\n  const peg$c3 = \"translate\";\n  const peg$c4 = \"scale\";\n  const peg$c5 = \"rotate\";\n  const peg$c6 = \"skewX\";\n  const peg$c7 = \"skewY\";\n  const peg$c8 = \",\";\n  const peg$c9 = \".\";\n\n  const peg$r0 = /^[eE]/;\n  const peg$r1 = /^[+\\-]/;\n  const peg$r2 = /^[0-9]/;\n  const peg$r3 = /^[ \\t\\r\\n]/;\n\n  const peg$e0 = peg$literalExpectation(\"matrix\", false);\n  const peg$e1 = peg$literalExpectation(\"(\", false);\n  const peg$e2 = peg$literalExpectation(\")\", false);\n  const peg$e3 = peg$literalExpectation(\"translate\", false);\n  const peg$e4 = peg$literalExpectation(\"scale\", false);\n  const peg$e5 = peg$literalExpectation(\"rotate\", false);\n  const peg$e6 = peg$literalExpectation(\"skewX\", false);\n  const peg$e7 = peg$literalExpectation(\"skewY\", false);\n  const peg$e8 = peg$literalExpectation(\",\", false);\n  const peg$e9 = peg$otherExpectation(\"fractionalConstant\");\n  const peg$e10 = peg$literalExpectation(\".\", false);\n  const peg$e11 = peg$classExpectation([\"e\", \"E\"], false, false, false);\n  const peg$e12 = peg$classExpectation([\"+\", \"-\"], false, false, false);\n  const peg$e13 = peg$classExpectation([[\"0\", \"9\"]], false, false, false);\n  const peg$e14 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\"], false, false, false);\n\n  function peg$f0(ts) {    return ts;  }\n  function peg$f1(t, ts) {    return t.concat(ts)  }\n  function peg$f2(a, b, c, d, e, f) {\n    return [{type: 'matrix', a: a, b: b, c: c, d: d, e: e, f: f}];\n  }\n  function peg$f3(tx, ty) {\n    var t = {type: 'translate', tx: tx};\n    if (ty) t.ty = ty;\n    return [t];\n  }\n  function peg$f4(sx, sy) {\n    var s = {type:'scale', sx: sx};\n    if (sy) s.sy = sy;\n    return [s];\n  }\n  function peg$f5(angle, c) {\n    var r = {type:'rotate', angle: angle};\n    if (c) {\n      r.cx = c[0];\n      r.cy = c[1];\n    }\n    return [r];\n  }\n  function peg$f6(angle) {\n    return [{type: 'skewX', angle: angle}];\n  }\n  function peg$f7(angle) {\n    return [{type: 'skewY', angle: angle}];\n  }\n  function peg$f8(f) {    return parseFloat(f.join(\"\"));  }\n  function peg$f9(i) {    return parseInt(i.join(\"\"));  }\n  function peg$f10(n) {    return n;  }\n  function peg$f11(n1, n2) {    return [n1, n2];  }\n  function peg$f12(ds) {    return ds.join(\"\");  }\n  function peg$f13(f, e) {    return [f, e || null].join(\"\")  }\n  function peg$f14(d, e) {    return [d, e].join(\"\")  }\n  function peg$f15(d1, d2) {    return [d1 ? d1.join(\"\") : null, \".\", d2.join(\"\")].join(\"\");  }\n  function peg$f16(d) {    return d.join(\"\");  }\n  function peg$f17(s, d) {    return ['e', s, d.join(\"\")].join(\"\")  }\n  let peg$currPos = options.peg$currPos | 0;\n  let peg$savedPos = peg$currPos;\n  const peg$posDetailsCache = [{ line: 1, column: 1 }];\n  let peg$maxFailPos = peg$currPos;\n  let peg$maxFailExpected = options.peg$maxFailExpected || [];\n  let peg$silentFails = options.peg$silentFails | 0;\n\n  let peg$result;\n\n  if (options.startRule) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos,\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$getUnicode(pos = peg$currPos) {\n    const cp = input.codePointAt(pos);\n    if (cp === undefined) {\n      return \"\";\n    }\n    return String.fromCodePoint(cp);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text, ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase, unicode) {\n    return { type: \"class\", parts, inverted, ignoreCase, unicode };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description };\n  }\n\n  function peg$computePosDetails(pos) {\n    let details = peg$posDetailsCache[pos];\n    let p;\n\n    if (details) {\n      return details;\n    } else {\n      if (pos >= peg$posDetailsCache.length) {\n        p = peg$posDetailsCache.length - 1;\n      } else {\n        p = pos;\n        while (!peg$posDetailsCache[--p]) {}\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column,\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos, offset) {\n    const startPosDetails = peg$computePosDetails(startPos);\n    const endPosDetails = peg$computePosDetails(endPos);\n\n    const res = {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column,\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column,\n      },\n    };\n    if (offset && peg$source && (typeof peg$source.offset === \"function\")) {\n      res.start = peg$source.offset(res.start);\n      res.end = peg$source.offset(res.end);\n    }\n    return res;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsetransformList() {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewsp();\n    }\n    s2 = peg$parsetransforms();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = [];\n    s4 = peg$parsewsp();\n    while (s4 !== peg$FAILED) {\n      s3.push(s4);\n      s4 = peg$parsewsp();\n    }\n    peg$savedPos = s0;\n    s0 = peg$f0(s2);\n\n    return s0;\n  }\n\n  function peg$parsetransforms() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsetransform();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsecommaWsp();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsecommaWsp();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetransforms();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f1(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsetransform();\n    }\n\n    return s0;\n  }\n\n  function peg$parsetransform() {\n    let s0;\n\n    s0 = peg$parsematrix();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsetranslate();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsescale();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parserotate();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseskewX();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseskewY();\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsematrix() {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c0) {\n      s1 = peg$c0;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWsp();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsenumber();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsecommaWsp();\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parsenumber();\n                if (s9 !== peg$FAILED) {\n                  s10 = peg$parsecommaWsp();\n                  if (s10 !== peg$FAILED) {\n                    s11 = peg$parsenumber();\n                    if (s11 !== peg$FAILED) {\n                      s12 = peg$parsecommaWsp();\n                      if (s12 !== peg$FAILED) {\n                        s13 = peg$parsenumber();\n                        if (s13 !== peg$FAILED) {\n                          s14 = peg$parsecommaWsp();\n                          if (s14 !== peg$FAILED) {\n                            s15 = peg$parsenumber();\n                            if (s15 !== peg$FAILED) {\n                              s16 = [];\n                              s17 = peg$parsewsp();\n                              while (s17 !== peg$FAILED) {\n                                s16.push(s17);\n                                s17 = peg$parsewsp();\n                              }\n                              if (input.charCodeAt(peg$currPos) === 41) {\n                                s17 = peg$c2;\n                                peg$currPos++;\n                              } else {\n                                s17 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$e2); }\n                              }\n                              if (s17 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s0 = peg$f2(s5, s7, s9, s11, s13, s15);\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetranslate() {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 9) === peg$c3) {\n      s1 = peg$c3;\n      peg$currPos += 9;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspNumber();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          s7 = [];\n          s8 = peg$parsewsp();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f3(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsescale() {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c4) {\n      s1 = peg$c4;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspNumber();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          s7 = [];\n          s8 = peg$parsewsp();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f4(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserotate() {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c5) {\n      s1 = peg$c5;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspTwoNumbers();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          s7 = [];\n          s8 = peg$parsewsp();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f5(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseskewX() {\n    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c6) {\n      s1 = peg$c6;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parsewsp();\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsewsp();\n          }\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s7 = peg$c2;\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseskewY() {\n    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c7) {\n      s1 = peg$c7;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parsewsp();\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsewsp();\n          }\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s7 = peg$c2;\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f7(s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsesign();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = peg$parsefloatingPointConstant();\n    if (s3 !== peg$FAILED) {\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f8(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parseintegerConstant();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f9(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWspNumber() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecommaWsp();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenumber();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f10(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWspTwoNumbers() {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecommaWsp();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenumber();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecommaWsp();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenumber();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f11(s2, s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWsp() {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewsp();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = [];\n      s4 = peg$parsewsp();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsewsp();\n      }\n      s1 = [s1, s2, s3];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsecomma();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsewsp();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsewsp();\n        }\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c8;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseintegerConstant() {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsedigitSequence();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f12(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsefloatingPointConstant() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefractionalConstant();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseexponent();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f13(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedigitSequence();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexponent();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f14(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefractionalConstant() {\n    let s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsedigitSequence();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c9;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e10); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsedigitSequence();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f15(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedigitSequence();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c9;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e10); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f16(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseexponent() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = input.charAt(peg$currPos);\n    if (peg$r0.test(s1)) {\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parsedigitSequence();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f17(s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesign() {\n    let s0;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r1.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigitSequence() {\n    let s0, s1;\n\n    s0 = [];\n    s1 = peg$parsedigit();\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsedigit();\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigit() {\n    let s0;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r2.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewsp() {\n    let s0;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r3.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e14); }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);\n  function peg$throw() {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n  if (options.peg$library) {\n    return /** @type {any} */ ({\n      peg$result,\n      peg$currPos,\n      peg$FAILED,\n      peg$maxFailExpected,\n      peg$maxFailPos,\n      peg$success,\n      peg$throw: peg$success ? undefined : peg$throw,\n    });\n  }\n  if (peg$success) {\n    return peg$result;\n  } else {\n    peg$throw();\n  }\n}\n\nconst peg$allowedStartRules = [\n  \"transformList\"\n];\n\nexport {\n  peg$allowedStartRules as StartRules,\n  peg$SyntaxError as SyntaxError,\n  peg$parse as parse\n};\n","import { parse } from './fromTransformAttribute.autogenerated'\n\n/**\n * Parser for SVG Trasform Attribute http://www.w3.org/TR/SVG/coords.html#TransformAttribute\n * @param transformString {string} Transform string as defined by w3 Consortium\n * @returns {MatrixDescriptor[]} Array of MatrixDescriptor\n *\n * @example\n * > fromTransformAttribute('translate(-10,-10) scale(2,2) translate(10,10)')\n * [\n *  { type: 'translate', tx: -10, ty: -10},\n *  { type: 'scale', sx: 2, sy: 2 },\n *  { type: 'translate', tx: 10, ty: 10}\n * ]\n *\n * > compose(fromDefinition(fromTransformAttribute('translate(-10, -10) scale(10, 10)')))\n * { a: 10, c: 0, e: -10, b: 0, d: 10, f: -10 }\n */\nexport function fromTransformAttribute (transformString) {\n  return parse(transformString)\n}\n","import { scale } from './scale'\nimport { compose } from './transform'\n/**\n * Decompose a matrix into translation, scaling and rotation components, optionally\n * take horizontal and vertical flip in to consideration.\n * Note this function decomposes a matrix in rotation -> scaling -> translation order. I.e. for\n * certain translation T {tx, ty}, rotation R and scaling S { sx, sy }, it's only true for:\n *  decomposeTSR(compose(T, S, R)) === { translate: T, rotation: R, scale: S }\n * composing in a different order may yield a different decomposition result.\n * @param matrix {Matrix} Affine Matrix\n * @param  flipX {boolean} Whether the matrix contains vertical flip, i.e. mirrors on x-axis\n * @param  flipY {boolean} Whether the matrix contains horizontal flip, i.e. mirrors on y-axis\n * @returns {Transform} A transform object consisted by its translation, scaling\n * and rotation components.\n */\nexport function decomposeTSR (matrix, flipX = false, flipY = false) {\n  // Remove flip from the matrix first - flip could be incorrectly interpreted as\n  // rotations (e.g. flipX + flipY = rotate by 180 degrees).\n  // Note flipX is a vertical flip, and flipY is a horizontal flip.\n  if (flipX) {\n    if (flipY) {\n      matrix = compose(matrix, scale(-1, -1))\n    } else {\n      matrix = compose(matrix, scale(1, -1))\n    }\n  } else if (flipY) {\n    matrix = compose(matrix, scale(-1, 1))\n  }\n\n  const a = matrix.a; const b = matrix.b\n  const c = matrix.c; const d = matrix.d\n  let scaleX, scaleY, rotation\n\n  if (a !== 0 || c !== 0) {\n    const hypotAc = Math.hypot(a, c)\n    scaleX = hypotAc\n    scaleY = (a * d - b * c) / hypotAc\n    const acos = Math.acos(a / hypotAc)\n    rotation = c > 0 ? -acos : acos\n  } else if (b !== 0 || d !== 0) {\n    const hypotBd = Math.hypot(b, d)\n    scaleX = (a * d - b * c) / hypotBd\n    scaleY = hypotBd\n    const acos = Math.acos(b / hypotBd)\n    rotation = Math.PI / 2 + (d > 0 ? -acos : acos)\n  } else {\n    scaleX = 0\n    scaleY = 0\n    rotation = 0\n  }\n\n  // put the flip factors back\n  if (flipY) {\n    scaleX = -scaleX\n  }\n\n  if (flipX) {\n    scaleY = -scaleY\n  }\n\n  return {\n    translate: { tx: matrix.e, ty: matrix.f },\n    scale: { sx: scaleX, sy: scaleY },\n    rotation: { angle: rotation }\n  }\n}\n","/**\n * Tranformation matrix that mirrors on x-axis\n * @returns {Matrix} Affine Matrix\n */\nexport function flipX () {\n  return {\n    a: 1,\n    c: 0,\n    e: 0,\n    b: 0,\n    d: -1,\n    f: 0\n  }\n}\n\n/**\n * Tranformation matrix that mirrors on y-axis\n * @returns {Matrix} Affine Matrix\n */\nexport function flipY () {\n  return {\n    a: -1,\n    c: 0,\n    e: 0,\n    b: 0,\n    d: 1,\n    f: 0\n  }\n}\n\n/**\n * Tranformation matrix that mirrors on origin\n * @returns {Matrix} Affine Matrix\n */\nexport function flipOrigin () {\n  return {\n    a: -1,\n    c: 0,\n    e: 0,\n    b: 0,\n    d: -1,\n    f: 0\n  }\n}\n","import { translate } from './translate'\nimport { applyToPoint } from './applyToPoint'\nimport { rotate } from './rotate'\nimport { scale } from './scale'\nimport { compose } from './transform'\n\n// https://manivannan-ai.medium.com/find-the-angle-between-three-points-from-2d-using-python-348c513e2cd\n\n/**\n * Calculate a transformation matrix from a point that starts from A to A'\n * This approach can be associated to a pointer that moves on a device\n * @param {Point} startingPoint - Starting point (A)\n * @param {Point} endingPoint - Ending point (A')\n */\nexport function fromOneMovingPoint (startingPoint, endingPoint) {\n  const tx = endingPoint.x - startingPoint.x\n  const ty = endingPoint.y - startingPoint.y\n\n  return translate(tx, ty)\n}\n\n/**\n * Calculate a transformation matrix about two points that move from positions A and B to A' and B'\n * This approach can be associated to a two finger gesture on a touch device\n * @param {Point} startingPoint1 - Starting Point (A)\n * @param {Point} startingPoint2 - Starting Point (B)\n * @param {Point} endingPoint1 - Ending point (A')\n * @param {Point} endingPoint2 - Ending Point (B')\n */\nexport function fromTwoMovingPoints (startingPoint1, startingPoint2, endingPoint1, endingPoint2) {\n  // finds translation\n  const translationMatrix = fromOneMovingPoint(startingPoint1, endingPoint1)\n\n  const pointA = applyToPoint(translationMatrix, startingPoint2) // I have to translate this point\n  const center = endingPoint1\n  const pointB = endingPoint2\n\n  // finds rotation matrix\n  const angle = Math.atan2(pointB.y - center.y, pointB.x - center.x) - Math.atan2(pointA.y - center.y, pointA.x - center.x)\n  const rotationMatrix = rotate(angle, center.x, center.y)\n\n  // finds scale matrix\n  const d1 = Math.sqrt(Math.pow(pointA.x - center.x, 2) + Math.pow(pointA.y - center.y, 2))\n  const d2 = Math.sqrt(Math.pow(pointB.x - center.x, 2) + Math.pow(pointB.y - center.y, 2))\n  const scalingLevel = d2 / d1\n  const scalingMatrix = scale(scalingLevel, scalingLevel, center.x, center.y)\n\n  return compose([\n    translationMatrix,\n    scalingMatrix,\n    rotationMatrix\n  ])\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","applyToPoint","matrix","point","Array","isArray","a","c","e","b","d","f","x","y","applyToPoints","points","map","fromObject","object","parseFloat","matrixRegex","fromString","string","parseFloatOrThrow","number","n","Number","isFinite","Error","concat","prefix","substring","toLowerCase","suffix","length","elements","split","fromStringLegacy","parsed","match","identity","inverse","denom","isUndefined","val","isNumeric","isNaN","isAffineMatrix","_typeof","translate","tx","arguments","undefined","transform","_len","matrices","_key","multiply","m1","m2","_matrices2","rest","slice","m","apply","_toConsumableArray","compose","cos","Math","sin","PI","rotate","angle","cx","cy","cosAngle","sinAngle","rotationMatrix","rotateDEG","scale","sx","sy","scaleMatrix","shear","shx","shy","tan","skew","ax","ay","skewDEG","toCSS","toString","toSVG","smoothMatrix","precision","round","fromTriangles","t1","t2","px1","py1","px2","py2","qx1","qy1","qx2","qy2","rx1","ry1","rx2","ry2","fromDefinition","definitionOrArrayOfDefinition","mapper","descriptor","type","ty","peg$SyntaxError","_SyntaxError","message","expected","found","location","_this","_classCallCheck","_callSuper","name","_inherits","sources","_this2","str","this","src","st","find","s","source","text","start","offset_s","offset","loc","line","column","end","filler","padEnd","hatLen","hex","ch","codePointAt","toUpperCase","nonPrintable","RegExp","unicodeEscape","replace","literalEscape","classEscape","DESCRIBE_EXPECTATION_FNS","literal","expectation","escapedParts","parts","part","inverted","join","unicode","any","other","description","describeExpectation","descriptions","sort","j","i","describeExpected","describeFound","_wrapNativeSuper","SyntaxError","peg$parse","input","options","peg$result","peg$FAILED","peg$source","grammarSource","peg$startRuleFunctions","transformList","peg$parsetransformList","peg$startRuleFunction","peg$c0","peg$c1","peg$c2","peg$c3","peg$c4","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$r0","peg$r1","peg$r2","peg$r3","peg$e0","peg$literalExpectation","peg$e1","peg$e2","peg$e3","peg$e4","peg$e5","peg$e6","peg$e7","peg$e8","peg$e9","peg$e10","peg$e11","peg$classExpectation","peg$e12","peg$e13","peg$e14","peg$currPos","peg$posDetailsCache","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","p","details","charCodeAt","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","res","peg$fail","push","s1","s2","s3","s4","peg$parsewsp","peg$parsetransforms","s0","ts","peg$parsetransform","peg$parsecommaWsp","s5","s7","s9","s11","s13","s15","s16","s17","substr","peg$parsenumber","peg$parsematrix","s6","s8","t","peg$parsecommaWspNumber","peg$parsetranslate","peg$parsescale","r","peg$parsecommaWspTwoNumbers","peg$parserotate","peg$parseskewX","peg$parseskewY","peg$parsesign","d1","d2","peg$parsedigitSequence","peg$parsefractionalConstant","peg$parseexponent","peg$parsefloatingPointConstant","peg$parseintegerConstant","parseInt","peg$parsecomma","charAt","test","peg$parsedigit","peg$success","peg$throw","cp","String","fromCodePoint","peg$getUnicode","buildMessage","peg$library","fromTransformAttribute","transformString","parse","decomposeTSR","flipX","flipY","scaleX","scaleY","rotation","hypotAc","hypot","acos","hypotBd","flipOrigin","fromOneMovingPoint","startingPoint","endingPoint","fromTwoMovingPoints","startingPoint1","startingPoint2","endingPoint1","endingPoint2","translationMatrix","pointA","center","pointB","atan2","sqrt","pow","scalingLevel"],"sourceRoot":""}